module ActionDispatch
  module Integration #:nodoc:
    module RequestHelpers
      def follow_redirect!
        raise "not a redirect! #{status} #{status_message}" unless redirect?

        # The original #follow_redirect! has a shortcoming in that it does not
        # re-send the original request's header. This is what Firefox, Chrome, Safari
        # and Curl do. The behavior is described here:
        #
        # RFC 9110 Section 15.4:
        # https://datatracker.ietf.org/doc/html/rfc9110#section-15.4
        #
        # When automatically following a redirected request, the user agent
        # SHOULD resend the original request message with the following
        # modifications:
        #
        # (...)
        #
        #    2.  Remove header fields that were automatically generated by the
        #        implementation, replacing them with updated values as appropriate
        #        to the new request.  This includes:
        #
        #        1.  Connection-specific header fields (see Section 7.6.1),
        #
        #        2.  Header fields specific to the client's proxy configuration,
        #            including (but not limited to) Proxy-Authorization,
        #
        #        3.  Origin-specific header fields (if any), including (but not
        #            limited to) Host,
        #
        #        4.  Validating header fields that were added by the
        #            implementation's cache (e.g., If-None-Match,
        #            If-Modified-Since), and
        #
        #        5.  Resource-specific header fields, including (but not limited
        #            to) Referer, Origin, Authorization, and Cookie.
        #
        #    3.  Consider removing header fields that were not automatically
        #        generated by the implementation (i.e., those present in the
        #        request because they were added by the calling context) where
        #        there are security implications; this includes but is not limited
        #        to Authorization and Cookie.

        former_headers = request.headers.to_h

        # It's hard to come up with a list of headers that are OK to be forwarded.
        # Since we only need to support X-Up headers for our tests, we only forward those.
        former_headers = former_headers.select { |k, v| k.starts_with?("HTTP_X_UP") }
        former_headers = former_headers.transform_keys { |k| k.sub(/^HTTP_/, '').dasherize }

        get(response.location, headers: former_headers)
        status
      end
    end
  end
end
